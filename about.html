<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.32">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>About – Bin Yu</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<script src="site_libs/quarto-html/quarto.js" type="module"></script>
<script src="site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-37eea08aefeeee20ff55810ff984fec1.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap-97b0f3e763d66a0e8f9e9a9f159311c2.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<script async="" src="https://siteimproveanalytics.com/js/siteanalyze_6294756.js"></script>


<link rel="stylesheet" href="styles.css">
</head>

<body class="nav-fixed quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="./index.html">
    <span class="navbar-title">Bin Yu</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="./index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link active" href="./about.html" aria-current="page"> 
<span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./people.html"> 
<span class="menu-text">People</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./papers.html"> 
<span class="menu-text">Papers</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./books.html"> 
<span class="menu-text">Books</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./software.html"> 
<span class="menu-text">Software</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./teaching.html"> 
<span class="menu-text">Teaching</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#about-bin-yu" id="toc-about-bin-yu" class="nav-link active" data-scroll-target="#about-bin-yu">About Bin Yu</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">About</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="about-bin-yu" class="level1">
<h1>About Bin Yu</h1>
<p>Bin Yu is the Chancellor’s Distinguished Professor in the UC Berkeley Departments of Statistics and EECS. She was Chair of the Department of Statistics at UC Berkeley from 2009 to 2012. She is a member of National Academy of Sciences and currently serves on the editorial board of Proceedings of National Academy of Sciences (PNAS).</p>
<p>Professor Bin Yu recieved a BS Degree in Mathematics from Peking University, and MS and Ph.D.&nbsp;in Statistics from UC Berkeley. She was a Member of Technical Staff at Lucent Bell-Labs, Distinguished Researcher in the Deep Learning Group of Microsoft Research, Assistant Professor at UW-Madison, and Miller Research Professor at Berkeley. She was a Visiting Faculty at MIT, Peking University, Newton Institute at Cambridge University, ETH, Yale University, Flatiron Institute, Poincare Institute, INRIA-Paris, and Fields Institute at University of Toronto.</p>
<p>Professor Bin Yu has published many research papers and one book, <em>Veridical Data Science</em> (MIT Press, 2024). Her research focuses on developing trustworthy and interpretable machine learning methods, with particular emphasis on the Predictability-Computability-Stability (PCS) framework for veridical data science. She has made fundamental contributions to statistical theory, including pioneering work on Vapnik-Chervonenkis (VC) theory for time series analysis, minimum description length (MDL) and entropy estimation, sparse modeling, boosting, spectral clustering, and MCMC convergence analysis. Her applied work spans neuroscience, genomics, remote sensing, and precision medicine, always emphasizing interdisciplinary collaboration with domain experts. Currently, she leads research in interpretable machine learning (including tree-based methods and deep learning interpretability), causal inference, and the development of stable, reproducible methods for scientific discovery. Her group has developed influential algorithms such as iterative random forests (iRF), contextual decomposition for transformers, and adaptive wavelet distillation for interpreting neural networks.</p>
<p>Professor Bin Yu has received many awards and honors throughout her career. She has been elected to the National Academy of Sciences and the American Academy of Arts and Sciences. Her major awards include the Guggenheim Fellowship, COPSS E. L. Scott Prize, and most recently, the COPSS Distinguished Achievement Award and Lecture (DAAL) (formerly Fisher Award and Lecture) at JSM in 2023. She has delivered several distinguished lectures, including the Wald Memorial Lectures of the Institute of Mathematical Statistics (IMS), the Tukey Memorial Lecture of the Bernoulli Society, and the Rietz Lecture of IMS. She holds an Honorary Doctorate from the University of Lausanne in Switzerland.</p>
<p>Professor Bin Yu has held many leadership positions in the statistical and data science communities. She served as President of the Institute of Mathematical Statistics (IMS) and was Chair of the Department of Statistics at UC Berkeley from 2009 to 2012. She served on the Inaugural Scientific Committee of the UK Turing Institute for Data Science and AI. Her editorial leadership includes current service on the Editorial Board of Proceedings of National Academy of Sciences (PNAS), and previous service on editorial boards of Annals of Statistics, Journal of American Statistical Association, and Journal of Machine Learning Research. Her committee and advisory work includes co-chairing the National Scientific Committee of the Statistical and Applied Mathematical Sciences Institute (SAMSI), serving on scientific advisory committees of SAMSI and IPAM, and on the board of trustees of ICERM and the Board of Governors of IEEE-IT Society. She recently served on the scientific advisory committee for the IAS Special Year on optimization, statistics and theoretical machine learning, and the Scientific Advisory Boards of Canadian Statistical Sciences Institute (CANSSI). Currently, she serves on the advisory board of the AI Policy Hub at UC Berkeley, the Scientific Advisory Committee of the Department of Quantitative and Computational Biology at USC, and on the External Advisory Committee for Learning the Earth with Artificial Intelligence and Physics (LEAP), an NSF Science and Technology Center (STC), at Columbia University. She is a Chan-Zuckerberg Biohub Investigator and Weill Neurohub Investigator. She is a member of the UC Berkeley Center for Computational Biology and serves as a scientific advisor at the Simons Institute for the Theory of Computing. <!-- 
# About Our Research Group

The [Yu Group](https://www.stat.berkeley.edu/~yugroup/) at Berkeley consists of a small group of students and postdocs from Statistics and EECS, developing cutting-edge statistical machine learning methods that have proven highly valuable in theortical and applied diciplines spanning a broad range from genetics to quantitative finance. Our graduates have achieved exceptional success in academia and industry, with notable alumni including Peng Zhao (CEO of Citadel Securities), and senior quantitative researchers at Citadel, Two Sigma, Bridgewater, and Voleon.

Our research focuses on developing stable, interpretable, and scalable methods. We have successfully built **real-time forecasting systems** for complex temporal data (including our [COVID-19 severity prediction](https://covidseverity.com/) system), developed **stability-driven machine learning frameworks** crucial for risk management, and created **interpretable deep learning methods** essential for regulatory compliance in financial applications.

The Yu Group has developed many fundamental statistical and machine learning methods, including [**stability-driven nonnegative matrix factorization (staNMF)**](https://github.com/Yu-Group/staNMF) for regime detection and factor modeling, [**iterative Random Forests (iRF)**](https://github.com/Yu-Group/iterative-Random-Forest) and [**signed iRF (s-iRF)**](https://github.com/karlkumbier/iRF2.0) for discovering complex market interactions and non-linear relationships, [**hierarchical shrinkage methods**](https://arxiv.org/abs/2202.00858) for robust prediction in high-dimensional settings, and [**contextual decomposition (CD)**](https://github.com/jamie-murdoch/ContextualDecomposition) and [**aggregated contextual decomposition (ACD)**](https://github.com/csinva/hierarchical-dnn-interpretations) for interpreting complex deep learning models in trading applications.

Our research covers several key areas:

## Deep Learning and Machine Learning

Our work in deep learning spans from theoretical understanding to practical applications across diverse domains. Key contributions include mechanistic interpretation through contextual decomposition in transformers, efficient fine-tuning methods like [LoRA+](https://github.com/nikhil-ghosh-berkeley/loraplus), and frameworks for understanding neural network dynamics. We've developed methods like [Adaptive Wavelet Distillation (AWD)](https://github.com/Yu-Group/adaptive-wavelets) for interpreting deep neural networks, and theoretical work on the three stages of dynamics in high-dimensional kernel methods. Our applications range from clinical decision-making in healthcare to cosmological analysis and financial modeling.

Selected recent papers:
- [LoRA+: Efficient Low Rank Adaptation of Large Models](https://arxiv.org/abs/2402.12354) (ICML 2024)
- [Mechanistic Interpretation through Contextual Decomposition in Transformers](https://arxiv.org/pdf/2407.00886) (2024)
- [Minimum-Norm Interpolation Under Covariate Shift](https://arxiv.org/pdf/2404.00522) (ICML 2024)
- [The three stages of dynamics in high-dimensional kernel methods](https://arxiv.org/abs/2111.07167) (ICLR 2022)

## Veridical Data Science (PCS)

The PCS (Predictability, Computability, Stability) framework represents our approach to responsible, reliable, and transparent data analysis. This framework unifies and expands on best practices in machine learning and statistics, ensuring that data science findings are both scientifically sound and practically actionable. The **Stability** component addresses model robustness and reproducibility, the **Predictability** component focuses on out-of-sample performance, and the **Computability** component ensures scalable implementation. Our work includes applications to genomics, clinical research, epidemiology, and quantitative finance, always emphasizing the importance of stability and reproducibility in scientific discovery.

Selected recent papers:
- [Veridical data science](https://www.stat.berkeley.edu/~binyu/ps/papers2020/VDS20-YuKumbier.pdf) (PNAS 2020) — foundational framework paper
- [Epistasis regulates genetic control of cardiac hypertrophy](https://www.medrxiv.org/content/10.1101/2023.11.06.23297858v1) (2023) — PCS application to genomics
- [After Computational Reproducibility: Scientific Reproducibility and Trustworthy AI](https://hdsr.mitpress.mit.edu/pub/8qexde24/release/1) (Harvard Data Science Review 2024)
- [Stable discovery of interpretable subgroups via calibration in causal studies (staDISC)](https://onlinelibrary.wiley.com/doi/10.1111/insr.12427)

## Interpretable Machine Learning

We develop methods to make machine learning models interpretable and trustworthy, particularly for high-stakes applications in healthcare, science, and finance. Our work spans contextual decomposition for understanding neural networks, feature importance frameworks, and methods for aligning model explanations with prior knowledge. We emphasize the principle that interpretations should be both faithful to the model and useful for human decision-making across diverse domains.

Selected recent papers:
- [Mechanistic Interpretation through Contextual Decomposition in Transformers](https://arxiv.org/pdf/2407.00886) (2024)
- [MDI+: a flexible random forest-based feature importance framework](https://arxiv.org/abs/2307.01932) (2023)
- [Tell your model where to attend: post-hoc attention steering for LLMs](https://arxiv.org/abs/2311.02262) (ICLR 2024)
- [Definitions, methods, and applications in interpretable machine learning](https://www.stat.berkeley.edu/~binyu/ps/papers2020/iML19-Murdochetal.pdf) (PNAS 2019)

## Tree-based Methods

We develop both theoretical understanding and practical improvements for tree-based methods, including random forests and gradient boosting. Our contributions include the iterative Random Forests (iRF) algorithm for discovering high-order interactions, hierarchical shrinkage methods for improving accuracy and interpretability, and fast interpretable greedy-tree sums (FIGS). We also provide theoretical analysis of when and why tree-based methods succeed or fail, with applications spanning from genomics to finance to clinical medicine.

Selected recent papers:
- [The Computational Curse of Big Data for Bayesian Additive Regression Trees: a Hitting Time Analysis](https://arxiv.org/pdf/2406.19958) (2024)
- [Fast interpretable greedy-tree sums (FIGS)](https://arxiv.org/abs/2201.11931) (2022)
- [Hierarchical shrinkage: improving accuracy and interpretability of tree-based methods](https://arxiv.org/abs/2202.00858) (ICML 2022)
- [Provable Boolean Interaction Recovery from Tree Ensemble obtained via Random Forests](https://arxiv.org/abs/2102.11800) (PNAS 2022)
- [iterative Random Forests to discover predictive and stable high-order interactions](https://www.stat.berkeley.edu/~binyu/ps/papers2018/iRF+SI18.pdf) (PNAS 2018)

## Quantitative Finance Applications

Our methods have proven particularly valuable in quantitative finance, where model stability, interpretability, and out-of-sample performance are crucial. Our graduates have achieved exceptional success at leading hedge funds including Citadel Securities (where Peng Zhao serves as CEO), Two Sigma, Bridgewater, and Voleon. We develop stability-driven approaches for regime detection, portfolio optimization, risk management, and alpha generation, always emphasizing robust performance across changing market conditions.

Key applications and alumni outcomes:
- **Real-time forecasting systems** for complex temporal data and market dynamics
- **Stability-driven frameworks** crucial for live trading environments
- **Interpretable models** essential for regulatory compliance and risk management
- **High-dimensional interaction discovery** for complex market relationship modeling

## Interdisciplinary Research in Biomedicine

Our biomedicine work applies statistical machine learning to problems in genomics, clinical prediction, and biomarker discovery. We collaborate closely with domain experts to develop methods that are both statistically rigorous and clinically meaningful. Recent work includes epistasis analysis for cardiac hypertrophy, metabolomic signatures for pancreatic cancer risk, and clinical AI modeling standards.

Selected recent papers:
- [Epistasis regulates genetic control of cardiac hypertrophy](https://www.medrxiv.org/content/10.1101/2023.11.06.23297858v1) (2023)
- [A blood-based metabolomic signature predictive of risk for pancreatic cancer](https://pubmed.ncbi.nlm.nih.gov/37729870/) (Cell Reports Medicine 2023)
- [Minimum information about clinical artificial intelligence modeling: the MI-CLAIM checklist](https://www.nature.com/articles/s41591-020-1041-y) (Nature Medicine 2020)
- [Unsupervised pattern discovery in spatial gene expression atlas reveals mouse brain regions beyond established ontology](https://www.biorxiv.org/content/10.1101/2023.03.10.531984v2) (2023)

Our graduates have achieved remarkable success across academia and industry, securing positions at leading institutions including top universities, major technology companies, and premier quantitative trading firms such as Citadel Securities, Two Sigma, Bridgewater, and Voleon. This success reflects the broad applicability of our research and the exceptional training our students receive in robust statistical methods, scalable machine learning, and rigorous mathematical foundations essential for tackling complex real-world problems.

Research is supported in part by grants from NSF, NIH, the Weill Neurohub, and the Simons Foundation.

- [Yu Group at Berkeley](https://www.stat.berkeley.edu/~yugroup/) for current group members and current projects
- [Papers](https://binyu.stat.berkeley.edu/papers)
- [Code](https://www.stat.berkeley.edu/~yugroup/code.html)
- [Statistical Machine Learning at Berkeley](http://www.stat.berkeley.edu/~statlearning/)

# Vision

My broad vision of data science best described in my article [Veridical Data Science](https://www.pnas.org/content/117/8/3920). In this work, I introduced a framework based on three principles: predictability, computability and stability (abbreviated to PCS). This framework helps guide practitioners who solve domain data problems with data science tools to be creative in their analysis and properly validate their findings. I have written a book on the Veridical Data Science framework together with my former student [Rebecca Barter](https://www.rebeccabarter.com/). The book is being published by the MIT Press in 2024 with a free on-line copy available soon.

She and her team have developed the PCS framework for veridical data science (or responsible, reliable, and transparent data analysis and decision-making). PCS stands for predictability, computability and stability, and it unifies, streamlines, and expands on ideas and best practices of machine learning and statistics.

In order to augment empirical evidence for decision-making, they are investigating statistical machine learning methods/algorithms (and associated statistical inference problems) such as dictionary learning, non-negative matrix factorization (NMF), EM and deep learning (CNNs and LSTMs), and heterogeneous effect estimation in randomized experiments (X-learner). Their recent algorithms include staNMF for unsupervised learning, iterative Random Forests (iRF) and signed iRF (s-iRF) for discovering predictive and stable high-order interactions in supervised learning, next generation tree-based methods (e.g. fast and interpretable greedy-tree sums (FIGS) and hierarchical shrinked (HS) trees, and RF+ ), contextual decomposition (CD), aggregated contextual decomposition (ACD), and adaptive wavelet distillation (AWD) for interpretation of Deep Neural Networks (DNNs). --></p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp("https:\/\/binyu\.stat\.berkeley\.edu");
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
<p>© Bin Yu</p>
</div>   
    <div class="nav-footer-center">
      &nbsp;
    </div>
    <div class="nav-footer-right">
      &nbsp;
    </div>
  </div>
</footer>




</body></html>